// Package main provides the file ingester agent for the GOX framework.
//
// The file ingester is a foundational agent that monitors directories for
// new files and generates messages to initiate processing pipelines. It
// serves as the entry point for file-based workflows, detecting file
// system events and converting them into agent messages.
//
// Key Features:
// - Directory monitoring with configurable watch intervals
// - File digest support to prevent duplicate processing
// - Configurable file extension filtering
// - Automatic message generation for detected files
// - Integration with GOX framework's FileIngressHandler
//
// Operation:
// The agent leverages the framework's built-in FileIngressHandler which
// handles the actual file watching, filtering, and message generation.
// This agent simply forwards the generated messages to the egress topic.
//
// Configuration (via cells.yaml):
// - ingress: "file:path/to/watch/*.ext" - Directory and pattern to monitor
// - egress: "pub:topic-name" - Topic to publish file notifications
// - digest: Enable/disable duplicate file detection
// - watch_interval_seconds: Polling interval for file detection
// - supported_extensions: Array of file extensions to monitor
//
// Called by: GOX orchestrator during pipeline initialization
// Calls: Framework FileIngressHandler, message forwarding to broker
package main

import (
	"fmt"
	"os"

	"github.com/agen/cellorg/internal/agent"
	"github.com/agen/cellorg/internal/client"
)

// FileIngester implements the AgentRunner interface for file monitoring.
//
// This agent acts as a lightweight message forwarder that works in conjunction
// with the framework's FileIngressHandler. The handler performs the actual
// file system monitoring and generates messages for detected files, while
// this agent ensures proper message forwarding to downstream processors.
//
// Thread Safety: The agent framework handles concurrency and message ordering
type FileIngester struct {
	agent.DefaultAgentRunner // Embed default implementations for Init/Cleanup
}

// ProcessMessage forwards file ingestion messages from the framework's FileIngressHandler.
//
// The FileIngressHandler automatically generates messages for files that match
// the configured patterns. This method receives those messages and forwards
// them unchanged to the egress topic for downstream processing.
//
// Parameters:
//   - msg: BrokerMessage generated by FileIngressHandler containing file metadata
//   - base: BaseAgent providing logging and framework integration
//
// Returns:
//   - *client.BrokerMessage: The original message to be published via egress
//   - error: Always nil for this passthrough operation
//
// Called by: GOX agent framework during message processing
// Calls: base.LogDebug() for operation logging
func (f *FileIngester) ProcessMessage(msg *client.BrokerMessage, base *agent.BaseAgent) (*client.BrokerMessage, error) {
	// File ingester receives generated messages from FileIngressHandler and forwards them
	// The actual file watching, filtering, and message generation is handled by the framework

	base.LogDebug("FileIngester forwarding message %s", msg.ID)

	// Return the message as-is to be published via egress topic
	// The framework will handle the actual publishing based on egress configuration
	return msg, nil
}

// main is the entry point for the file ingester agent.
//
// Initializes and starts the agent using the GOX framework's agent runner.
// The framework handles all boilerplate including broker connection,
// message routing, lifecycle management, and the FileIngressHandler setup.
//
// The agent ID "file-ingester" is used for:
// - Agent registration with the support service
// - Logging and debugging identification
// - Message routing and correlation
//
// Called by: Operating system process execution
// Calls: agent.Run() with FileIngester implementation
func main() {
	// Framework handles all boilerplate including file watching, broker connection,
	// message routing, and lifecycle management
	if err := agent.Run(&FileIngester{}, "file-ingester"); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
