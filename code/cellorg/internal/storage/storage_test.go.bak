package storage

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/tenzoki/gox/internal/client"
)

// MockBrokerClient implements the broker client interface for testing
type MockBrokerClient struct {
	publishedMessages []client.BrokerMessage
	responseHandlers  map[string]func(*client.BrokerMessage)
}

func NewMockBrokerClient() *MockBrokerClient {
	return &MockBrokerClient{
		publishedMessages: make([]client.BrokerMessage, 0),
		responseHandlers:  make(map[string]func(*client.BrokerMessage)),
	}
}

func (m *MockBrokerClient) Publish(topic string, msg client.BrokerMessage) error {
	m.publishedMessages = append(m.publishedMessages, msg)
	return nil
}

func (m *MockBrokerClient) Subscribe(topic string) error {
	return nil
}

func (m *MockBrokerClient) RegisterHandler(messageType string, handler func(*client.BrokerMessage) error) {
	m.responseHandlers[messageType] = func(msg *client.BrokerMessage) {
		handler(msg)
	}
}

// Simulate receiving a response message
func (m *MockBrokerClient) SimulateResponse(requestID string, success bool, result interface{}, errorMsg string) {
	response := StorageResponse{
		Success:   success,
		Result:    result,
		Error:     errorMsg,
		RequestID: requestID,
	}

	responseBytes, _ := json.Marshal(response)
	msg := &client.BrokerMessage{
		ID:      uuid.New().String(),
		Type:    "storage_response",
		Payload: responseBytes,
	}

	// Simulate response handling
	if handler, exists := m.responseHandlers["storage_response"]; exists {
		handler(msg)
	}
}

// Get the last published message for testing
func (m *MockBrokerClient) GetLastMessage() *client.BrokerMessage {
	if len(m.publishedMessages) == 0 {
		return nil
	}
	return &m.publishedMessages[len(m.publishedMessages)-1]
}

func TestNewClient(t *testing.T) {
	agentID := "test-agent-001"
	brokerClient := NewMockBrokerClient()

	if client == nil {
		t.Fatal("Expected storage client to be created")
	}

	if client.agentID != agentID {
		t.Errorf("Expected agent ID %s, got %s", agentID, client.agentID)
	}

		t.Error("Expected broker client to be set correctly")
	}


		t.Error("Expected responses map to be initialized")
	}
}

func TestNewHTTPClient(t *testing.T) {
	baseURL := "http://localhost:8080"

	client := NewHTTPClient(baseURL)
	if client == nil {
		t.Fatal("Expected HTTP client to be created")
	}

	if client.baseURL != baseURL {
		t.Errorf("Expected base URL %s, got %s", baseURL, client.baseURL)
	}

	if client.httpClient == nil {
		t.Error("Expected HTTP client to be initialized")
	}

	if client.httpClient.Timeout != 30*time.Second {
		t.Errorf("Expected HTTP client timeout 30s, got %v", client.httpClient.Timeout)
	}
}

func TestSetTimeout(t *testing.T) {

	newTimeout := 10 * time.Second
	client.SetTimeout(newTimeout)

	if client.timeout != newTimeout {
		t.Errorf("Expected timeout %v, got %v", newTimeout, client.timeout)
	}
}

func TestKVSetRequest(t *testing.T) {
	brokerClient := NewMockBrokerClient()

	err := client.KVSet("test-key", "test-value")
	if err != nil {
		t.Fatalf("Failed to set KV pair: %v", err)
	}

	// Verify message was published
	lastMsg := brokerClient.GetLastMessage()
	if lastMsg == nil {
		t.Fatal("Expected message to be published")
	}

	if lastMsg.Type != "storage_request" {
		t.Errorf("Expected message type 'storage_request', got %s", lastMsg.Type)
	}

	if lastMsg.Target != "pub:storage-requests" {
		t.Errorf("Expected target 'pub:storage-requests', got %s", lastMsg.Target)
	}

	// Parse and verify request payload
	var request StorageRequest
	payloadBytes, ok := lastMsg.Payload.([]byte)
	if !ok {
		t.Fatal("Expected payload to be []byte")
	}

	err = json.Unmarshal(payloadBytes, &request)
	if err != nil {
		t.Fatalf("Failed to unmarshal request: %v", err)
	}

	if request.Operation != "kv_set" {
		t.Errorf("Expected operation 'kv_set', got %s", request.Operation)
	}

	if request.Key != "test-key" {
		t.Errorf("Expected key 'test-key', got %s", request.Key)
	}

	if request.Value != "test-value" {
		t.Errorf("Expected value 'test-value', got %v", request.Value)
	}
}

func TestKVGetWithResponse(t *testing.T) {
	brokerClient := NewMockBrokerClient()

	// Set up response handler

	// Start the get operation in a goroutine
	resultChan := make(chan interface{}, 1)
	errorChan := make(chan error, 1)

	go func() {
		result, err := client.KVGet("test-key")
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- result
		}
	}()

	// Give the goroutine time to send the request
	time.Sleep(10 * time.Millisecond)

	// Get the request that was sent
	lastMsg := brokerClient.GetLastMessage()
	if lastMsg == nil {
		t.Fatal("Expected request message to be sent")
	}

	// Parse request to get request ID
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	// Simulate successful response
	brokerClient.SimulateResponse(request.RequestID, true, "test-value", "")

	// Wait for result
	select {
	case result := <-resultChan:
		if result != "test-value" {
			t.Errorf("Expected result 'test-value', got %v", result)
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestKVExists(t *testing.T) {
	brokerClient := NewMockBrokerClient()

	// Set up response handler

	// Test key exists
	resultChan := make(chan bool, 1)
	errorChan := make(chan error, 1)

	go func() {
		exists, err := client.KVExists("test-key")
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- exists
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Get request and simulate response
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	brokerClient.SimulateResponse(request.RequestID, true, true, "")

	select {
	case exists := <-resultChan:
		if !exists {
			t.Error("Expected key to exist")
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestCreateVertex(t *testing.T) {
	brokerClient := NewMockBrokerClient()

	properties := map[string]interface{}{
		"name": "test vertex",
		"type": "test",
		"value": 42,
	}

	// Set up response handler

	resultChan := make(chan string, 1)
	errorChan := make(chan error, 1)

	go func() {
		vertexID, err := client.CreateVertex("test_label", properties)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- vertexID
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "graph_create_vertex" {
		t.Errorf("Expected operation 'graph_create_vertex', got %s", request.Operation)
	}

	if request.Key != "test_label" {
		t.Errorf("Expected key 'test_label', got %s", request.Key)
	}

	// Simulate successful response
	expectedVertexID := "vertex-123"
	brokerClient.SimulateResponse(request.RequestID, true, expectedVertexID, "")

	select {
	case vertexID := <-resultChan:
		if vertexID != expectedVertexID {
			t.Errorf("Expected vertex ID %s, got %s", expectedVertexID, vertexID)
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestCreateEdge(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	err := client.CreateEdge("vertex1", "vertex2", "CONNECTS_TO")
	if err != nil {
		t.Fatalf("Failed to create edge: %v", err)
	}

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "graph_create_edge" {
		t.Errorf("Expected operation 'graph_create_edge', got %s", request.Operation)
	}

	edgeData, ok := request.Value.(map[string]interface{})
	if !ok {
		t.Fatal("Expected edge data to be map[string]interface{}")
	}

	if edgeData["from"] != "vertex1" {
		t.Errorf("Expected from 'vertex1', got %v", edgeData["from"])
	}

	if edgeData["to"] != "vertex2" {
		t.Errorf("Expected to 'vertex2', got %v", edgeData["to"])
	}

	if edgeData["label"] != "CONNECTS_TO" {
		t.Errorf("Expected label 'CONNECTS_TO', got %v", edgeData["label"])
	}
}

func TestGraphQuery(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	query := "g.V().has('type', 'test').limit(10)"
	resultChan := make(chan []interface{}, 1)
	errorChan := make(chan error, 1)

	go func() {
		results, err := client.GraphQuery(query)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- results
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "graph_query" {
		t.Errorf("Expected operation 'graph_query', got %s", request.Operation)
	}

	if request.Query != query {
		t.Errorf("Expected query %s, got %s", query, request.Query)
	}

	// Simulate successful response
	expectedResults := []interface{}{
		map[string]interface{}{"id": "1", "name": "test1"},
		map[string]interface{}{"id": "2", "name": "test2"},
	}
	brokerClient.SimulateResponse(request.RequestID, true, expectedResults, "")

	select {
	case results := <-resultChan:
		if len(results) != 2 {
			t.Errorf("Expected 2 results, got %d", len(results))
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestStoreFile(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	fileData := []byte("This is test file content")
	metadata := map[string]interface{}{
		"filename": "test.txt",
		"size":     len(fileData),
		"type":     "text/plain",
	}

	resultChan := make(chan string, 1)
	errorChan := make(chan error, 1)

	go func() {
		hash, err := client.StoreFile(fileData, metadata)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- hash
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "file_store" {
		t.Errorf("Expected operation 'file_store', got %s", request.Operation)
	}

	if string(request.FileData) != string(fileData) {
		t.Error("Expected file data to match")
	}

	// Simulate successful response
	expectedHash := "abc123def456"
	brokerClient.SimulateResponse(request.RequestID, true, expectedHash, "")

	select {
	case hash := <-resultChan:
		if hash != expectedHash {
			t.Errorf("Expected hash %s, got %s", expectedHash, hash)
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestRetrieveFile(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	fileHash := "abc123def456"
	expectedData := []byte("Retrieved file content")

	resultChan := make(chan []byte, 1)
	errorChan := make(chan error, 1)

	go func() {
		data, err := client.RetrieveFile(fileHash)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- data
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "file_retrieve" {
		t.Errorf("Expected operation 'file_retrieve', got %s", request.Operation)
	}

	if request.Key != fileHash {
		t.Errorf("Expected key %s, got %s", fileHash, request.Key)
	}

	// Test different response formats

	// Test 1: String response
	brokerClient.SimulateResponse(request.RequestID, true, string(expectedData), "")

	select {
	case data := <-resultChan:
		if string(data) != string(expectedData) {
			t.Error("Expected string data to be converted to bytes correctly")
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestRetrieveFileByteArray(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	fileHash := "def456ghi789"
	expectedData := []byte("Test byte array")

	resultChan := make(chan []byte, 1)
	errorChan := make(chan error, 1)

	go func() {
		data, err := client.RetrieveFile(fileHash)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- data
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Get request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	// Test slice of numbers response format
	numberSlice := make([]interface{}, len(expectedData))
	for i, b := range expectedData {
		numberSlice[i] = float64(b)
	}

	brokerClient.SimulateResponse(request.RequestID, true, numberSlice, "")

	select {
	case data := <-resultChan:
		if string(data) != string(expectedData) {
			t.Error("Expected number slice to be converted to bytes correctly")
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestIndexContent(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	contentID := "doc-001"
	content := "This is test content for full-text indexing"
	metadata := map[string]interface{}{
		"title":  "Test Document",
		"author": "Test Author",
		"type":   "article",
	}

	err := client.IndexContent(contentID, content, metadata)
	if err != nil {
		t.Fatalf("Failed to index content: %v", err)
	}

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "fulltext_index" {
		t.Errorf("Expected operation 'fulltext_index', got %s", request.Operation)
	}

	if request.Key != contentID {
		t.Errorf("Expected key %s, got %s", contentID, request.Key)
	}

	if request.Value != content {
		t.Errorf("Expected value %s, got %v", content, request.Value)
	}

	if len(request.Metadata) != len(metadata) {
		t.Error("Expected metadata to be included in request")
	}
}

func TestSearchContent(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	searchTerms := "test content machine learning"
	resultChan := make(chan []interface{}, 1)
	errorChan := make(chan error, 1)

	go func() {
		results, err := client.SearchContent(searchTerms)
		if err != nil {
			errorChan <- err
		} else {
			resultChan <- results
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "fulltext_search" {
		t.Errorf("Expected operation 'fulltext_search', got %s", request.Operation)
	}

	if request.SearchTerms != searchTerms {
		t.Errorf("Expected search terms %s, got %s", searchTerms, request.SearchTerms)
	}

	// Simulate successful response
	expectedResults := []interface{}{
		map[string]interface{}{
			"id":    "doc-001",
			"title": "Test Document 1",
			"score": 0.95,
		},
		map[string]interface{}{
			"id":    "doc-002",
			"title": "Test Document 2",
			"score": 0.87,
		},
	}
	brokerClient.SimulateResponse(request.RequestID, true, expectedResults, "")

	select {
	case results := <-resultChan:
		if len(results) != 2 {
			t.Errorf("Expected 2 search results, got %d", len(results))
		}
	case err := <-errorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for response")
	}
}

func TestBatchCreateVertices(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	vertices := []BatchVertex{
		{
			ID:    "vertex-1",
			Label: "person",
			Properties: map[string]interface{}{
				"name": "John Doe",
				"age":  30,
			},
		},
		{
			ID:    "vertex-2",
			Label: "person",
			Properties: map[string]interface{}{
				"name": "Jane Smith",
				"age":  25,
			},
		},
		{
			ID:    "vertex-3",
			Label: "company",
			Properties: map[string]interface{}{
				"name":     "Tech Corp",
				"industry": "technology",
			},
		},
	}

	err := client.BatchCreateVertices(vertices)
	if err != nil {
		t.Fatalf("Failed to batch create vertices: %v", err)
	}

	// Should create separate requests for each label
	messages := brokerClient.publishedMessages
	if len(messages) < 2 {
		t.Errorf("Expected at least 2 batch requests (one per label), got %d", len(messages))
	}

	// Verify request structure
	for _, msg := range messages {
		var request StorageRequest
		payloadBytes, _ := msg.Payload.([]byte)
		json.Unmarshal(payloadBytes, &request)

		if request.Operation != "batch_create_vertices" {
			t.Errorf("Expected operation 'batch_create_vertices', got %s", request.Operation)
		}

		requestData, ok := request.Value.(map[string]interface{})
		if !ok {
			t.Fatal("Expected request value to be map[string]interface{}")
		}

		label, exists := requestData["label"]
		if !exists {
			t.Error("Expected label in batch request")
		}

		vertices, exists := requestData["vertices"]
		if !exists {
			t.Error("Expected vertices in batch request")
		}

		if label == "person" {
			verticesList, ok := vertices.([]BatchVertex)
			if !ok {
				t.Error("Expected vertices to be []BatchVertex")
			} else if len(verticesList) != 2 {
				t.Errorf("Expected 2 person vertices, got %d", len(verticesList))
			}
		}
	}
}

func TestBatchCreateEdges(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	edges := []BatchEdge{
		{From: "vertex-1", To: "vertex-2", Label: "KNOWS"},
		{From: "vertex-1", To: "vertex-3", Label: "WORKS_FOR"},
		{From: "vertex-2", To: "vertex-3", Label: "WORKS_FOR"},
	}

	err := client.BatchCreateEdges(edges)
	if err != nil {
		t.Fatalf("Failed to batch create edges: %v", err)
	}

	// Verify request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "batch_create_edges" {
		t.Errorf("Expected operation 'batch_create_edges', got %s", request.Operation)
	}

	// Verify edges in request (JSON marshaling/unmarshaling changes type)
	requestBytes, _ := json.Marshal(request.Value)
	var requestEdges []BatchEdge
	json.Unmarshal(requestBytes, &requestEdges)

	if len(requestEdges) != 3 {
		t.Errorf("Expected 3 edges in request, got %d", len(requestEdges))
	}
}

func TestHandleResponse(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Create a mock response channel
	requestID := uuid.New().String()
	responseChan := make(chan StorageResponse, 1)
	client.responses[requestID] = responseChan

	// Create test response message
	response := StorageResponse{
		Success:   true,
		Result:    "test result",
		RequestID: requestID,
	}

	responseBytes, _ := json.Marshal(response)
	msg := &client.BrokerMessage{
		ID:      uuid.New().String(),
		Type:    "storage_response",
		Payload: responseBytes,
	}

	// Handle the response
	err := client.HandleResponse(msg)
	if err != nil {
		t.Fatalf("Failed to handle response: %v", err)
	}

	// Verify response was delivered to channel
	select {
	case receivedResponse := <-responseChan:
		if receivedResponse.RequestID != requestID {
			t.Errorf("Expected request ID %s, got %s", requestID, receivedResponse.RequestID)
		}
		if !receivedResponse.Success {
			t.Error("Expected successful response")
		}
		if receivedResponse.Result != "test result" {
			t.Errorf("Expected result 'test result', got %v", receivedResponse.Result)
		}
	case <-time.After(100 * time.Millisecond):
		t.Fatal("Response was not delivered to channel")
	}
}

func TestHandleResponseNonStorageMessage(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Create non-storage message
	msg := &client.BrokerMessage{
		ID:      uuid.New().String(),
		Type:    "other_message_type",
		Payload: []byte("{}"),
	}

	// Should not error but should ignore the message
	err := client.HandleResponse(msg)
	if err != nil {
		t.Errorf("Expected no error for non-storage message, got: %v", err)
	}
}

func TestTransactionOperations(t *testing.T) {
	brokerClient := NewMockBrokerClient()
	client := NewClient("test-agent", brokerClient)

	// Set up response handler
	client.brokerClient.RegisterHandler("storage_response", client.HandleResponse)

	// Test begin transaction
	txResultChan := make(chan TransactionID, 1)
	txErrorChan := make(chan error, 1)

	go func() {
		txID, err := client.BeginTransaction()
		if err != nil {
			txErrorChan <- err
		} else {
			txResultChan <- txID
		}
	}()

	time.Sleep(10 * time.Millisecond)

	// Verify begin transaction request
	lastMsg := brokerClient.GetLastMessage()
	var request StorageRequest
	payloadBytes, _ := lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "begin_transaction" {
		t.Errorf("Expected operation 'begin_transaction', got %s", request.Operation)
	}

	// Simulate successful response
	expectedTxID := "tx-123"
	brokerClient.SimulateResponse(request.RequestID, true, expectedTxID, "")

	var txID TransactionID
	select {
	case txID = <-txResultChan:
		if string(txID) != expectedTxID {
			t.Errorf("Expected transaction ID %s, got %s", expectedTxID, string(txID))
		}
	case err := <-txErrorChan:
		t.Fatalf("Unexpected error: %v", err)
	case <-time.After(1 * time.Second):
		t.Fatal("Timeout waiting for transaction begin response")
	}

	// Test commit transaction
	err := client.CommitTransaction(txID)
	if err != nil {
		t.Fatalf("Failed to commit transaction: %v", err)
	}

	// Verify commit request
	lastMsg = brokerClient.GetLastMessage()
	payloadBytes, _ = lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "commit_transaction" {
		t.Errorf("Expected operation 'commit_transaction', got %s", request.Operation)
	}

	if request.Key != string(txID) {
		t.Errorf("Expected key %s, got %s", string(txID), request.Key)
	}

	// Test rollback transaction
	err = client.RollbackTransaction(txID)
	if err != nil {
		t.Fatalf("Failed to rollback transaction: %v", err)
	}

	// Verify rollback request
	lastMsg = brokerClient.GetLastMessage()
	payloadBytes, _ = lastMsg.Payload.([]byte)
	json.Unmarshal(payloadBytes, &request)

	if request.Operation != "rollback_transaction" {
		t.Errorf("Expected operation 'rollback_transaction', got %s", request.Operation)
	}
}

func TestRequestResponseStructures(t *testing.T) {
	// Test StorageRequest JSON marshaling/unmarshaling
	request := StorageRequest{
		Operation:   "test_operation",
		Key:         "test-key",
		Value:       map[string]interface{}{"test": "value"},
		Query:       "test query",
		SearchTerms: "search terms",
		FileData:    []byte("file content"),
		Metadata:    map[string]interface{}{"meta": "data"},
		RequestID:   "req-123",
	}

	requestBytes, err := json.Marshal(request)
	if err != nil {
		t.Fatalf("Failed to marshal request: %v", err)
	}

	var unmarshalledRequest StorageRequest
	err = json.Unmarshal(requestBytes, &unmarshalledRequest)
	if err != nil {
		t.Fatalf("Failed to unmarshal request: %v", err)
	}

	if unmarshalledRequest.Operation != request.Operation {
		t.Errorf("Expected operation %s, got %s", request.Operation, unmarshalledRequest.Operation)
	}

	// Test StorageResponse JSON marshaling/unmarshaling
	response := StorageResponse{
		Success:   true,
		Result:    map[string]interface{}{"result": "data"},
		Error:     "",
		RequestID: "req-123",
	}

	responseBytes, err := json.Marshal(response)
	if err != nil {
		t.Fatalf("Failed to marshal response: %v", err)
	}

	var unmarshalledResponse StorageResponse
	err = json.Unmarshal(responseBytes, &unmarshalledResponse)
	if err != nil {
		t.Fatalf("Failed to unmarshal response: %v", err)
	}

	if unmarshalledResponse.Success != response.Success {
		t.Errorf("Expected success %v, got %v", response.Success, unmarshalledResponse.Success)
	}
}

func TestKVSetGetDelete(t *testing.T) {
	request := KVSetRequest{
		Key:   "test-key",
		Value: "test-value",
	}

	if request.Key != "test-key" {
		t.Errorf("Expected key 'test-key', got %s", request.Key)
	}

	if request.Value != "test-value" {
		t.Errorf("Expected value 'test-value', got %v", request.Value)
	}

	// Test KVResponse
	response := KVResponse{
		Success: true,
		Key:     "test-key",
		Value:   "retrieved-value",
	}

	if !response.Success {
		t.Error("Expected successful response")
	}

	if response.Key != "test-key" {
		t.Errorf("Expected key 'test-key', got %s", response.Key)
	}
}